package io.github.alluhemanth.chess.core

import io.github.alluhemanth.chess.core.board.Board
import io.github.alluhemanth.chess.core.board.Square
import io.github.alluhemanth.chess.core.game.GameResult
import io.github.alluhemanth.chess.core.game.GameState
import io.github.alluhemanth.chess.core.game.GameUtils
import io.github.alluhemanth.chess.core.move.LegalMoveGenerator
import io.github.alluhemanth.chess.core.move.Move
import io.github.alluhemanth.chess.core.piece.PieceColor
import io.github.alluhemanth.chess.core.utils.FenUtils
import io.github.alluhemanth.chess.core.utils.PgnUtils
import io.github.alluhemanth.chess.core.utils.SanUtils

/**
 * The ChessGame class represents a complete chess game, managing the board state, move history, and game logic.
 * It provides methods for making moves, undoing/redoing moves, loading/saving positions in FEN/PGN formats, and querying
 * the game's status. This class encapsulates the rules and mechanics of chess, ensuring valid gameplay and tracking
 * the progression of the game.
 *
 * ## Overview
 * - Tracks the current [Board] state and [GameState], including turn, castling rights, en passant targets, and clocks.
 * - Maintains a history of moves and positions for undo/redo functionality and repetition detection.
 * - Supports legal move generation, move validation, and game result determination.
 * - Provides utility methods for interacting with the game using SAN (Standard Algebraic Notation) and UCI (Universal Chess Interface).
 *
 * ## Internal Implementation Details
 * ### State Management
 * - The current board state is stored in the [board] property, and the game state in [gameState].
 * - Move history is tracked in [moveHistory], with [currentMoveIndex] indicating the active move.
 * - Position history is stored as FEN strings in [positionHistory] for repetition detection and undo/redo functionality.
 *
 * ### Move Handling
 * - The system validates moves against the list of legal moves generated by [LegalMoveGenerator].
 * - It handles special moves such as castling, en passant, and pawn promotion seamlessly.
 * - It supports undo and redo by replaying moves from the initial position.
 *
 * ### Example of Usage
 * ```kotlin
 * val game = ChessGame()
 * println(game.getBoard()) // Print initial board
 * game.makeSanMove("e4")
 * game.makeSanMove("e5")
 * println(game.getFen()) // Print FEN after two moves
 * ```
 *
 * ## Example of Internal Access
 * ```kotlin
 * val game = ChessGame()
 * val legalMoves = game.getLegalMoves()
 * val move = legalMoves.first()
 * game.makeMove(move)
 * println(game.getFen())
 * ```
 *
 * @property board The current board state.
 * @property gameState The current game state (turn, castling rights, etc.).
 * @property moveHistory The list of moves made in the game.
 * @property currentMoveIndex The index of the current move in the move history.
 * @property positionHistory The list of FEN strings representing the position after each move.
 */
@Suppress("unused")
class ChessGame(
    private var board: Board = Board.Companion.initialBoard(),
    private var gameState: GameState = GameState.Companion.newGame(),
    private val moveHistory: MutableList<Move> = mutableListOf(),
    private var currentMoveIndex: Int = -1,
    private val positionHistory: MutableList<String> = mutableListOf()
) {

    private val legalMoveGenerator = LegalMoveGenerator()

    init {
        positionHistory.add(getFen())
    }

    /**
     * Returns the current [Board] state.
     *
     * @example
     * ```kotlin
     * val game = ChessGame()
     * val board = game.getBoard()
     * println(board)
     * ```
     */
    fun getBoard(): Board = board.copy()

    /**
     * Returns the current [GameState].
     */
    fun getGameState(): GameState = gameState

    /**
     * Returns the [io.github.alluhemanth.chess.core.piece.PieceColor] of the player whose turn it is.
     *
     * @example
     * ```kotlin
     * val game = ChessGame()
     * println(game.getCurrentPlayer()) // PieceColor.WHITE
     * ```
     */
    fun getCurrentPlayer(): PieceColor = gameState.currentPlayer

    /**
     * Returns true if the game is over, false otherwise.
     */
    fun isGameOver(): Boolean = getGameResult().isOver

    /**
     * Returns the current [io.github.alluhemanth.chess.core.game.GameResult], determining if the game is ongoing, drawn, or won.
     */
    fun getGameResult(): GameResult {
        if (gameState.halfMoveClock >= 100) {
            return GameResult.Draw.FiftyMoveRule
        }
        if (GameUtils.hasInsufficientMaterial(board)) {
            return GameResult.Draw.InsufficientMaterial
        }
        val currentFen = getFen().split(" ").take(4).joinToString(" ")
        val repetitionCount = positionHistory.count { it.split(" ").take(4).joinToString(" ") == currentFen }
        if (repetitionCount >= 3) {
            return GameResult.Draw.ThreefoldRepetition
        }
        val legalMoves = legalMoveGenerator.getAllLegalMoves(board, gameState)
        if (legalMoves.isEmpty()) {
            return if (GameUtils.isKingInCheck(gameState.currentPlayer, board)) {
                GameResult.Win(gameState.opponent())
            } else {
                GameResult.Draw.Stalemate
            }
        }
        return GameResult.Ongoing
    }

    /**
     * Returns a list of all legal moves for the current player.
     *
     * @example
     * ```kotlin
     * val game = ChessGame()
     * val moves = game.getLegalMoves()
     * println(moves)
     * ```
     */
    fun getLegalMoves(): List<Move> =
        legalMoveGenerator.getAllLegalMoves(board, gameState)

    /**
     * Makes the given [move] if it is legal, updating the board and game state.
     *
     * @param move The move to make.
     * @return True if the move was made, false if it was illegal.
     *
     * @example
     * ```kotlin
     * val game = ChessGame()
     * val move = game.getLegalMoves().first()
     * val success = game.makeMove(move)
     * ```
     */
    fun makeMove(move: Move): Boolean {
        val legalMoves = getLegalMoves()
        if (move !in legalMoves) return false

        // Clear redo history
        if (currentMoveIndex < moveHistory.size - 1) {
            moveHistory.subList(currentMoveIndex + 1, moveHistory.size).clear()
        }

        val (newBoard, newGameState) = GameUtils.makeMove(board, gameState, move)
        board = newBoard
        gameState = newGameState
        moveHistory.add(move)
        currentMoveIndex++
        positionHistory.add(getFen())
        return true
    }

    /**
     * Makes a move from a SAN (Standard Algebraic Notation) string.
     *
     * @param san The SAN string representing the move.
     * @return True if the move was made, false otherwise.
     *
     * @example
     * ```kotlin
     * val game = ChessGame()
     * game.makeSanMove("e4")
     * ```
     */
    fun makeSanMove(san: String): Boolean {
        val move = SanUtils.sanToMove(san, board, gameState)
        return makeMove(move)
    }

    /**
     * Makes a move from a UCI (Universal Chess Interface) string.
     *
     * @param uci The UCI string representing the move.
     * @return True if the move was made, false otherwise.
     *
     * @example
     * ```kotlin
     * val game = ChessGame()
     * game.makeUciMove("e2e4")
     * ```
     */
    fun makeUciMove(uci: String): Boolean {
        val fromSquare = Square(uci.substring(0, 2))
        val toSquare = Square(uci.substring(2, 4))
        val promotionChar = uci.getOrNull(4)
        val move = Move(fromSquare, toSquare, promotionChar)
        return makeMove(move)
    }

    /**
     * Undo the last move, if possible.
     *
     * @return True if a move was undone, false otherwise.
     *
     * @example
     * ```kotlin
     * val game = ChessGame()
     * game.makeSanMove("e4")
     * game.undo()
     * ```
     */
    fun undo(): Boolean {
        if (currentMoveIndex < 0) return false
        currentMoveIndex--
        replayMoves()
        return true
    }

    /**
     * Redo the previously undone move, if possible.
     *
     * @return True if a move was redone, false otherwise.
     *
     * @example
     * ```kotlin
     * val game = ChessGame()
     * game.makeSanMove("e4")
     * game.undo()
     * game.redo()
     * ```
     */
    fun redo(): Boolean {
        if (currentMoveIndex >= moveHistory.size - 1) return false
        currentMoveIndex++
        replayMoves()
        return true
    }

    /**
     * Returns the FEN (Forsyth-Edwards Notation) string for the current position.
     *
     * @example
     * ```kotlin
     * val game = ChessGame()
     * println(game.getFen())
     * ```
     */
    fun getFen(): String =
        FenUtils.getFenFromBoardAndState(board, gameState)

    /**
     * Loads a position from a FEN string, resetting move and position history.
     *
     * @param fen The FEN string to load.
     *
     * @example
     * ```kotlin
     * val game = ChessGame()
     * game.loadFen("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1")
     * ```
     */
    fun loadFen(fen: String) {
        val (newBoard, newGameState) = FenUtils.parseFen(fen)
        board = newBoard
        gameState = newGameState
        moveHistory.clear()
        currentMoveIndex = -1
        positionHistory.clear()
        positionHistory.add(getFen())
    }

    /**
     * Returns the PGN (Portable Game Notation) string for the current game.
     */
    fun getPgn(): String {
        val pgnMoves = mutableListOf<String>()
        val tempGame = ChessGame()
        for (move in moveHistory) {
            pgnMoves.add(SanUtils.moveToSan(move, tempGame.board, tempGame.gameState))
            tempGame.makeMove(move)
        }
        return pgnMoves.joinToString(" ")
    }

    /**
     * Loads a game from a PGN string, resetting the board and game state.
     *
     * @param pgn The PGN string to load.
     */
    fun loadPgn(pgn: String) {
        val pgnGame = PgnUtils.parsePgn(pgn)
        val (newBoard, newGameState) = PgnUtils.applyPgnMoves(pgnGame)
        board = newBoard
        gameState = newGameState
        moveHistory.clear()
        currentMoveIndex = -1
    }

    /**
     * Replays all moves up to the current move index, updating the board and position history.
     */
    private fun replayMoves() {
        val (newBoard, newGameState) = FenUtils.parseFen(FenUtils.DEFAULT_FEN)
        board = newBoard
        gameState = newGameState
        positionHistory.clear()
        for (i in 0..currentMoveIndex) {
            val (nextBoard, nextGameState) = GameUtils.makeMove(board, gameState, moveHistory[i])
            board = nextBoard
            gameState = nextGameState
            positionHistory.add(getFen())
        }
    }

}